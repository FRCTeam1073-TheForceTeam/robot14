/* FIRST Team 1073's RobotBuilder (0.0.2) for WPILibExtensions ---
Do not mix this code with any other version of RobotBuilder! */
#include "DriveTrain.h"
#include "../Robotmap.h"
#include "../Commands/Drive.h"
#define high DoubleSolenoid::kForward
#define off DoubleSolenoid::kOff
#define low DoubleSolenoid::kReverse
const float twistConst = .8;
static const float DEADZONE = .02;
static const float TWIST_DEADZONE = .01;
static const float MECANUM_CONSTANT = 1.4142; //square root of 2, since it's going to be used a lot
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	rightBack = RobotMap::driveTrainRightBack;
	leftBack = RobotMap::driveTrainLeftBack;
	rightFront = RobotMap::driveTrainRightFront;
	leftFront = RobotMap::driveTrainLeftFront;
	gyro = RobotMap::driveTrainGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}
    
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Drive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveTrain::MecanumDriveAction(float joyX, float joyY, float joystickTwist) {
	//Do math operation to given angle from joystick based on selected drive mode
	float joystickAngle = atan2(-joyX, -joyY);
	float actualAngle;
	float robotAngle;
	
	if(isFieldOriented){
		robotAngle = (gyro->GetAngle())*(PI/180.0f);
		actualAngle = joystickAngle - robotAngle;
	}
	else if(isTankDriveMode){
		actualAngle = 0;
	}
	else{
		actualAngle = joystickAngle;
	}
	
	float joystickMagnitude = sqrt(joyY * joyY + joyX * joyX); //get magnitude of joystick value via pythag theorem
	//Calculations for mecanum to work
	
	if(isTankDriveMode)	//tank mode should work now
			joystickMagnitude = -joyY;
		
		rightFront = joystickMagnitude * (cos(actualAngle) - sin(actualAngle));
		rightBack = joystickMagnitude * (cos(actualAngle) + sin(actualAngle));
		leftFront = joystickMagnitude * (cos(actualAngle) + sin(actualAngle));
		leftBack = joystickMagnitude * (cos(actualAngle) - sin(actualAngle));
		
		rightFront += joystickTwist * TWIST_CONSTANT;
		rightBack += joystickTwist * TWIST_CONSTANT; 
		leftFront -= joystickTwist * TWIST_CONSTANT;
		leftBack -= joystickTwist * TWIST_CONSTANT;
}
