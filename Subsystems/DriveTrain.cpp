/* FIRST Team 1073's RobotBuilder (0.0.2) for WPILibExtensions ---
Do not mix this code with any other version of RobotBuilder! */
#include "DriveTrain.h"
#include "../Robotmap.h"
#include "../Commands/Drive.h"
#define high DoubleSolenoid::kForward
#define off DoubleSolenoid::kOff
#define low DoubleSolenoid::kReverse
const float TWIST_CONSTANT = 0.8f;
const float TIMES_PER_SEC = 0.1f;
static const float MECANUM_CONSTANT = 1.4142; //square root of 2, since it's going to be used a lot
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	rightBack = RobotMap::driveTrainRightBack;
	leftBack = RobotMap::driveTrainLeftBack;
	rightFront = RobotMap::driveTrainRightFront;
	leftFront = RobotMap::driveTrainLeftFront;
	gyro = RobotMap::driveTrainGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	isFieldOrientation = false; 
	rampIteration = 0;
}
    
void DriveTrain::InitDefaultCommand() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Drive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveTrain::ToggleOrientation(){
	isFieldOrientation = !isFieldOrientation; 	
}
bool DriveTrain::IsFieldOrientation(){
	return isFieldOrientation;
}
void DriveTrain::MecanumDriveAction(float joystickX, float joystickY, float joystickTwist) {
	//TODO Needs adjustment to scaling and possibly other things
	
	double joyAngle = atan2(joystickX, joystickY);
	float joystickMagnitude = sqrt((joystickX * joystickX) + (joystickY * joystickY));
	if(joystickTwist < 0.05 && joystickTwist > -0.05){
		joystickTwist = 0.0;
	}
	float ccTwist = joystickTwist * TWIST_CONSTANT;
	float twist = -joystickTwist * TWIST_CONSTANT;
	double actAngle = joyAngle; 
	if (isFieldOrientation) {
		float robAngle = (gyro->GetAngle())*(PI/180.0f);
		actAngle -= robAngle;
	}
	
	float leftFrontVal = -1 * (ccTwist + joystickMagnitude*(cos(actAngle)+sin(actAngle)));
	float rightFrontVal = (twist + joystickMagnitude*(cos(actAngle)-sin(actAngle)));
	float leftBackVal= -1 * (ccTwist + joystickMagnitude*(cos(actAngle)-sin(actAngle)));
	float rightBackVal = (twist + joystickMagnitude*(cos(actAngle)+sin(actAngle)));
	//do ramping
	float dr = DriveRamp(0.1f);
	if(fabs(dr) >= 1){
		dr = (dr < 0 ? -1 : 1);
		rampIteration = 0;
		puts("Ramping maxed out.");
	}
	leftFrontVal *= dr;
	rightFrontVal *= dr;
	leftBackVal *= dr;
	rightBackVal *= dr;
	rampIteration++;
	puts("Ramping complete.");
	//end ramping
	leftFront->Set(leftFrontVal);
	rightFront->Set(rightFrontVal);
	leftBack->Set(leftBackVal);
	rightBack->Set(rightBackVal);
	
	/*
	
	printf("Gyro Angle:%f\tActual Angle:%f\n", gyro->GetAngle(), actAngle);
	
	
	printf("Right Front:%f", rightFrontVal);
	printf("Left Front:%f", leftFrontVal);
	printf("Right Back:%f", rightBackVal);
	printf("Left Back:%f", leftBackVal);
	printf("Joysick X:%f Joystick Y:%f Twist:%f\n",joystickX,joystickY, joystickTwist);
	*/
}
void DriveTrain::StopMotors(){
	leftFront->Set(0);
	rightFront->Set(0);
	leftBack->Set(0);
	rightBack->Set(0);
	}
double DriveTrain::DriveRamp(float magnitude){
	return (double)(magnitude * rampIteration * TIMES_PER_SEC);
}
