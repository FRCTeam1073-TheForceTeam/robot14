/* FIRST Team 1073's RobotBuilder (0.0.2) for WPILibExtensions ---
Do not mix this code with any other version of RobotBuilder! */
#include "DriveTrain.h"
#include "../Robotmap.h"
#include "../Commands/Drive.h"
#define high DoubleSolenoid::kForward
#define off DoubleSolenoid::kOff
#define low DoubleSolenoid::kReverse
const float TWIST_CONSTANT = .8;
static const float MECANUM_CONSTANT = 1.4142; //square root of 2, since it's going to be used a lot
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	rightBack = RobotMap::driveTrainRightBack;
	leftBack = RobotMap::driveTrainLeftBack;
	rightFront = RobotMap::driveTrainRightFront;
	leftFront = RobotMap::driveTrainLeftFront;
	gyro = RobotMap::driveTrainGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}
    
void DriveTrain::InitDefaultCommand() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Drive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveTrain::MecanumDriveAction(float joystickX, float joystickY, float joystickTwist) {
	//TODO Needs adjustment to scaling and possibly other things
	
	double angle = atan2(joystickX, joystickY);
	float joystickMagnitude = sqrt((joystickX * joystickX) + (joystickY * joystickY));
	
	rightFront->Set((joystickMagnitude*(cos(angle)-sin(angle)))/(2*sqrt(2)));
	leftFront->Set((joystickMagnitude*(cos(angle)+sin(angle)))/(2*sqrt(2)));
	leftBack->Set((joystickMagnitude*(cos(angle)-sin(angle)))/(2*sqrt(2)));
	rightBack->Set((joystickMagnitude*(cos(angle)+sin(angle)))/(2*sqrt(2)));
}
